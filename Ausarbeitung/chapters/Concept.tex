% !TeX spellcheck = <none>
\chapter{Application concept}

This chapter describes the project plan and the concepts for the developed application. These concepts are foundation of the developed application and describe how the internal processes in the application work.


\section{Project planning}

The project followed the incremental development model. For initial planning the features from existing cost estimation software as described in section \ref{sec:stateofart}. The next step was creating a \textit{GUI prototype} to show how the estimation would look like on a smartphone. Afterwards each cycle followed the rules of incremental development. An evaluation of the wanted features for the application was done in meetings with my supervisor Prof. Dr. Georg Rock. Those features request were compiled into the project goals and requirements. For the next step they were analyzed and implemented. Testing for the application were made afterwards by some of my fellow students. The result was then presented in a meeting and further features were planned for the next iteration cycle.
\begin{figure}[h] 
	\centering 
	\includegraphics[width=14cm]{images/iterativeDev.PNG} 
	\caption{- Incremental Development} 
	Source: \url{https://www.inflectra.com/Methodologies/}
	\label{fig:incrementaldev}
\end{figure}\\


\subsection{Objectives}\label{objectives}

The project targets are the benefit the application should bring the user. They are linked with the requirements from section \ref{requirements} and describe the condition to be achieved with the application. Whereas requirements can change over time, targets stay the same.\\
Most important target, as described in table \ref{projecttargets}, is \textit{T01}. 'The application must allow a quick and mobile cost estimation of IT Projects' describes that the cost estimation has to be implemented for mobile device use. Also, the cost estimation has to be fast and can use features of the mobile platform to achieve this target.\\
As the developed application is only a beta version, it has to be developed modular for future feature implementation, as described in \textit{T04}.\\
\textit{T06} describes the target that represents an admired feature. The application should provide the possibility to compare projects and measure their relation. This allows to check previous projects for their cost estimation, that the user has a reference how much effort similar projects took.\\
The target for this bachelor thesis is to implement the function point estimation technique. This is the showcase for this application and shows the possibility of cost estimations for software project on mobile devices and is described in \textit{T09}.\\
All remaining targets are medium priority and describe what processes to achieve with this project.\\

\begin{table}[h]
	\centering 
	\setlength{\tabcolsep}{4pt}
	\begin{tabular}{|l||p{14cm}|}\hline
		ID		& Target\\ \hline\hline
		T01  	& The application must allow a quick and mobile cost estimation of IT Projects.\\ \hline
		T02  	& The application must provide informations how cost estimations work.\\ \hline
		T03  	& The application have to improve the cost estimation during  the project life cycle.\\ \hline
		T04  	& The application architecture has to be modular to add new cost estimation methods and analysis tools faster and more efficient.\\ \hline
		T05  	& With the application it is possible to get the information of completed projects and take advantage of their estimation.\\ \hline
		T06  	& The application allows comparison between projects and shows projects that are related to each other.\\ \hline
		T07  	& The application gives information about the estimated man days of a project and the estimated costs.\\ \hline
		T08  	& A project analysis within the application allows an overview of the project changes and gives detailed information about the estimation.\\ \hline
		T09  	& Till the end of the bachelor thesis the function point method has to be implemented and be fully operational.\\ \hline
	\end{tabular} 
	\caption{Project Targets} 
	\label{projecttargets} 
\end{table}

\subsection{Requirements}\label{requirements}

All requirements for the implemented application are based on the targets described in section \ref{objectives} and from the regular meetings. All requirements are described in the appendix XXXX and meet the demands for requirements as described by Balzert \cite{basiskonzepteRE}.\\


\subsection{Cost Estimation}
For the evaluation of the needed time, the project was estimated with the function point technique. Therefor all functionalities are grouped into functional groups, as described by Poensgen \cite{FPKompakt}. Afterwards each function was assigned a category for the estimation, as described in \ref{fpcomponents}.\\
The group Project, as described in \ref{fig:projectFunctionalityGroup}, inherits all functions for a project. All function groups for the application can be found in the application. The project functionalities in \ref{fig:projectFunctionalityGroup} are created with the requirements. Some requirements can be grouped into one functionality. As an example the function \textit{Create/Edit Project} inherits all requirements described in the appendix XXX. This function is marked as an \textit{EI} and \textit{ILF} because all changes are made by the user for this function and creates or edit all internal files for the project. \\
\begin{figure}[h] 
	\centering 
	\includegraphics[width=14cm]{images/ScreenOverviewProject.PNG} 
	\caption{- Function Group - Project} 
	\label{fig:projectFunctionalityGroup}
\end{figure}\\
Functions that expects an input from the user are marked as \textit{EI}, like delete project. Output functions like show estimated cost are a \textit{EO} function, because they only display values and results to the user. Functions with a calculation are described as \textit{EQ} combined with \textit{EO} if they produce an output like \textit{Export Project} or process an \textit{Input} like \textit{Change Estimation}.The total functional group can be found in the appendix. This categorization of the function groups was inserted into the estimation table as described in table \ref{estimation:data}.Summed up the project has total \textbf{246} \textit{Function Points}.
\begin{table}[h]
	\centering 
	\setlength{\tabcolsep}{4pt}
	\begin{tabular}{|l|c|c|c|c|}\hline
		Category		&  Amount 		&  Classification	&  Weight 	& Sum of Row\\ \hline
		Input Data   	& 17      		& medium  			& 4			& 68	\\ \hline
		Request Data   	& 6      		& simple  			& 3			& 18	\\ \hline
		Output Data   	& 8      		& medium  			& 5			& 40	\\ \hline
		Dataset   		& 8      		& complex  			& 15		& 120	\\ \hline
		Reference Data  & 0      		& simple  			& 5			& 0	\\ \hline
		\textbf{Sum}   			&       		&   				& 			& \textbf{246}	\\ \hline
	\end{tabular} 
	\caption{Estimation - Total Points} 
	\label{estimation:data} 
\end{table}\\
As described in section \ref{FPMethod}, the next step is to set the influence factors which are described in table \ref{estimation:influence}. The influence factor \textit{Integration into other applications} is set to two because the application has no direct communication to other software. The application does not work with other applications but has local data, like the databases that have to be processed which is the reason for setting the factor \textit{Local Data Processing} to two. As the application is only a local software for the end users device their no much transaction to be excepted. To assure that there is enough time planned to implement a access to the database this factor is set to one. There are many algorithms and equations in the application which have to be checked for errors and exceptions. Also a high effort for the logical component is to be expected. Because of this all influence factors in the \textit{Processing Logic} group are set to the second highest value. For further development of the application a high effort has to be expected for \textit{Reusability} in the project which is the reason for this influence factor to be set at two. There is not much data to be expected from other applications. Only the database cause a higher effort with queries to transform the data from the database in readable informations for the application. Changes in the application can not be made by the user. He can change settings and some appearances which is why this influence factor is set to one. Completed with the equation from \ref{FPMethod} all influence factors result in a multiplier of \textbf{1.01}. Together with the total function points, the influence multiplier is calculated with the equation \ref{fp:TFP} which give \textbf{243.54} points as result. Calculated with the points per day from table \ref{tab:pointsperday} the project is estimated to take \textbf{14} man days. In section \ref{result} it is analyzed how this estimation has worked out and how much time the project took.\\
\begin{table}[h]
	\centering 
	\setlength{\tabcolsep}{4pt}
	\begin{tabular}{|l|c|}\hline
		Influence Factor						&  Weight 	\\ \hline
		Integration into other applications   	& 2      		\\ \hline
		Local Data Processing   				& 2      		\\ \hline
		Transaction Rate   						& 1      		\\ \hline
		Processing Logic   						&       		\\ \hline
		\phantom{ab}- Arithmetic Operation   					& 4      		\\ \hline
		\phantom{ab}- Control Procedure   					& 4      		\\ \hline
		\phantom{ab}- Exception Regulation   					& 8      		\\ \hline
		\phantom{ab}- Logic   								& 4      		\\ \hline
		Reusability   							& 3      		\\ \hline
		Stock Conversion  						& 2      		\\ \hline
		Facilitate Change   					& 1      		\\ \hline
		\textbf{Sum}   									& \textbf{31}      		\\ \hline
	\end{tabular} 
	\caption{Estimation - Influence Factors} 
	\label{estimation:influence} 
\end{table}

\section{Architecture}

The architecture of the project is described as a component diagram in fig. \ref{fig:components}. As usual in Android developments all resources are stored in the \textit{resources} folder and are accessible from all other classes. The resources inherits \textit{strings}, \textit{images} and many more. Most used in the same folder is the \textit{Layout Data} which inherits all informations for displaying the user interface. Layout informations are connected with the \textit{Activities} and \textit{Fragments} component which are responsible to display the user interface.\\
The \textit{Project Analyzer} component is responsible for collecting the data from all projects and put them together for analysis. As the name says, \textit{Project Data} contains all informations for a single project. For reading and storing data to the database the component \textit{Database Helper} is the part that allows simple \textit{Data Requests} and \textit{Data Insertions} to the database. It also allows a connection to the \textit{XML Helper} which reads data that is stored to XML files. The

\begin{figure}[h] 
	\centering 
	\includegraphics[width=14cm]{images/components.jpg} 
	\caption{- Component Diagram} 
	\label{fig:components}
\end{figure}

\section{Components}

This section describes the most important components from figure \ref{fig:components} in detail and what concepts they inherit. 

\subsection{Database Helper}

The \textit{Database Helper} component is responsible for accessing the database, where all project informations are stored. Every Class that needs access to the database should only create an object of this component and can read or write data to the database.\\
The component should contain name and path to the database and allow the initialization of the database. As described in fig. \ref{fig:sequenceDBHelper}, with the message \textit{Open Constructor}, an initialization of the database should be done in the constructor of classes that need access to it. This will opens the \textit{SQLite} database and ensures that request on the database can be performed and no error occurs while accessing a non initialized database. All functionalities that are working on the database are in fig. \ref{fig:sequenceDBHelper} combined to the message \textit{Using Class} and combines the three categories for working with the database \textit{SELECT}, \textit{ALTER} and \textit{DELETE}.\\ 
For requesting data from the database a Java class has to send a request with the table name and the selection criteria to the Database Helper. This will be transformed into a query which is send to the database. Before sending this data back to the calling Java class the database Helper has to transform the \textit{SQL} query result into readable information. Editing existing informations in the database is done with the message \textit{Alter Existing Data} and the parameters table name and data to be edited. Before sending data to the database the \textit{Database Helper} has to prepare it to insert them in the right column of the table. This query will return true if inserting was successful or false if it was not. Last message option is \textit{Delete Data} which will delete entries from the database. The parameter \textit{tablename} and \textit{Data ID} are the identifiers for a selected entry. Before deleting data from the database the \textit{Database Helper} has to check if there are any other tables depending to the selected entry and have to ensure that they are deleted too if necessary. After all depending tables are identified the Database Helper will send the delete query to the database. It will then return a boolean value for the deletion process which is forwarded to the Java Class.

\begin{figure}[h] 
	\centering 
	\includegraphics[width=14cm]{images/DBHelper.jpg} 
	\caption{- DB Helper Sequence Model} 
	\label{fig:sequenceDBHelper}
\end{figure}

\subsection{Project Data}

The \textit{Project Data} component was created to make combine all data of a project from the database and make it accessible for other classes. It contains \textit{Name}, \textit{Description}, \textit{Creation Date} and \textit{Estimation Technique} at the first level of the component. This makes it possible to get a fast overview of the different projects in the application. For estimation specific purposes the \textit{Estimation Items} and \textit{Influence Factor} are minor components for the project data and differ from the projects estimation technique. The \textit{Properties} are also a minor component to build a module-based structure. As the output information of estimation techniques is the same, the main component contains the amount of \textit{Estimated Man Days} for the project. If the project is completed the \textit{Final Man Days} represent the time the project really took. This value is important to improve future estimations as described in section \ref{adjustedEstimationProcess}, where the improvement process is specified.
\begin{figure}[h] 
	\centering 
	\includegraphics[width=10cm]{images/ObjectDiagramProject.png} 
	\caption{- Object Diagram for Projects} 
	\label{fig:objectDiagrammProject}
\end{figure}

\subsubsection{Project Properties}

This minor component contains the information that is needed for the \textit{Project Relation Solver} in section \ref{projectRealtionSolver}. It is a data component which stores all properties that allows reading and editing. Access to is granted to the properties only through the project component which assures that a property is bound to a project.\\
The available properties are based upon the parts a project can be split to. Not every available factor of a project makes sense for categorizing it. For example a categorization into the size of the project makes no sense as this cannot be compared to a project that is not estimated or developed. Although a categorization in the costs makes no sense as it cannot be compared to a project that has to be estimated. For this reason the available properties are \textit{Development Market}, \textit{Development Type}, \textit{Procedure Model}, \textit{Platform}, \textit{Industry Sector}, \textit{Programming Language} and \textit{Software Architecture}. These values categorize a project without saying something about the size or cost and make it possible to compare them.\\
All project properties contain only a selection of the possible values as a showcase. For each category are further options possible. For properties where this is a important factor these are combined in the option \textit{other}.\\
\subsubsection{Estimation Items}

All items for the estimation are in the \textit{Estimation Items} components. These are the items for an estimation technique that are responsible for the estimation itself. In the \textit{Function Point} estimation for example, these items calculate the value \textit{E1} from the equation \ref{fp:E1}.\\

\subsubsection{Influence Factors}

This component contains all informations for \textit{Influence Factors}. These are \textit{name}, \textit{chosen value} and the \textit{limit} for the value. This component is also responsible for preprocessing the influence factor for usable information at the calculation of the estimation. In the Function Point estimation for example, this component calculated the value \textit{E2} and \textit{E3} that are described in section \ref{fp:classificationInfluence}.\\

\subsection{Project Relation Solver}\label{projectRealtionSolver}

To fulfill the target \textit{T06} from section \ref{objectives}, this component is responsible to find related project. The point of this component is to compare already existing projects with a selected one. This should help the user to get an overview of how similar projects were estimated. Furthermore the \textit{Project Relation Solver} should allow to transfer the estimation from a related project to the selected to have an estimation where the user can build on.\\
The \textit{Project Relation Solver} compares therefor an selected project with every other available project from the database. This comparison is made in mainly three steps.
\paragraph*{\textbf{1. Determination of the Property Distances}}
Each project has seven different properties which are crucial for finding a relation plus the estimation technique. These properties are \textit{Development Market}, \textit{Development Kind}, \textit{Procedure Model}, \textit{Platform}, \textit{Industry Sector}, \textit{Programming Language} and \textit{Software Architecture}. The first step for calculating the project relation is to compare each property and get the distance. Each of them has its own calculation for the distance and a different weight to fit in the \textit{total distance} equation. 

\paragraph*{\textbf{Estimation Technique}}

The selected estimation technique may not be one of the available properties but it will still influence the relation between project. As it should be possible to transfer the estimation from a related project this feature is not possible if these projects do not use the same estimation technique. So it is an important factor for the calculation. But simply with the value 0 if they are equal or 0 if they are not, this factor is integrated into the relation calculation.

\paragraph*{\textbf{Development Market}}
The \textit{Development Market} property stands for the target market of a project and has three possible options: \textit{Inhouse Development}, \textit{Customer Development} and the \textit{Anonymous Market}. For calculating the distance between development markets it was analyzed for whom the project is developed, what is the main factor for the budget, how high is the risk of development and how predictable profit is.\\ 
The \textit{Inhouse Development} is a for developing projects in the company. They are usually have the same procedure as other project despite the fact that they don't yield a profit and have a low risk of development and a fixed budget. In the \textit{Customer Development} the risk depends on the customer needs but are predictable. Profit is to be expected high and is connected with the project budget. By \textit{Anonymous Market} developments a high risk is to be expected. Regardless of market analysis it is unsure that the project will be a success and generate profit. The budget for this market type is set from the company itself.\\
All distances between these markets are described in table \ref{property:devmarket} and are based on the above description. For example, the development for a customer is quite similar to an anonymous market development the distance between those is set to one. The big difference is that the profit is unsure for the anonymous market development. When comparing similar markets to each other the distance is zero as they are the same.
\begin{table}[h]
	\centering 
	\setlength{\tabcolsep}{4pt}
	\begin{tabular}{|l|l|c|}\hline
		Development Market		& Compared to 			&  Distance 	\\ \hline
		Inhouse Development   	& Customer Development	& 2      		\\ \hline
		Customer Development   	& Anonymous Market 		& 1      		\\ \hline
		Anonymous Market   		& Inhouse Development 	& 3     		\\ \hline
	\end{tabular} 
	\caption{Development Market - Distance} 
	\label{property:devmarket} 
\end{table}
\paragraph*{\textbf{Development Type}}
Different \textit{Development Types} describe the main reason for the project. A \textit{New Project} is developed if there is no previous project to build on or is a new conceptual formulation. An \textit{Extension Project} is made for expansion of existing software from previous projects. The third type are \textit{Research Projects} which are usually made to test an idea or create a prototype for an analysis. These development types can be differentiated in the \textit{main target} of the project, \textit{customer} and \textit{profit level}. To introduce this differentiation the profit level describes the expected money and is divided into values from zero to two. \textit{Zero} declines that the project does not generate any profit. The value \textit{one} expects medium profit and \textit{two} expects a high profit for the project.\\
The distances described in table \ref{property:devtype} are based on the above descriptions. A comparison between new projects and research project has the distance two. A research project does not generate any profit and has a different target than a new project. The same applies with the comparison of an extension project with a research project. By comparing a new project to an extension project the distance is set to one because the expected profit is smaller than in a new project. The reason for this is that an extension project builds up on a previous project and is an addition to a previous contract which normally get a smaller budget.\\
\begin{table}[h]
	\centering 
	\setlength{\tabcolsep}{4pt}
	\begin{tabular}{|l|l|c|}\hline
		Development Type		& Compared to 			&  Distance 	\\ \hline
		New Project   			& Research Project		& 2      		\\ \hline
		Extension Project   	& New Project 			& 1      		\\ \hline
		Research Project   		& Extension Project 	& 2     		\\ \hline
	\end{tabular} 
	\caption{Development Market - Distance} 
	\label{property:devtype} 
\end{table}
\paragraph*{\textbf{Procedure Model}}
The next property is the used procedure model. There are six procedure models for selection available. The distance in table \ref{property:proceduremodel} is calculated by differentiating each procedure by model type, suitable team size, formalization, industry focus and process cover. Model type simply splits the procedure models in sequential and iterative types. The suitable team size indicates the laid out size of team members are useful for this model. Formalization indicates how much has to be put into the documentation of the process steps and the process cover describes if the procedure model involves all main project processes which are development, test project management, quality assurance and the change management.\\
VERGLEICH BESCHREIBEN
\begin{table}[h]
	\centering 
	\setlength{\tabcolsep}{4pt}
	\begin{tabular}{|l|l|c|}\hline
		Procedure Model			& Compared to 	&  Distance 	\\ \hline
		Scrum   				& V-Model		& 5      		\\ \hline
		Waterfall Model   		& V-Model 		& 3      		\\ \hline
		Spiral Model   			& V-Model 		& 4     		\\ \hline
		Iterative Development   & V-Model 		& 4     		\\ \hline
		Prototyping  			& V-Model 		& 6     		\\ \hline
	\end{tabular} 
	\caption{Procedure Model - Distance} 
	\label{property:proceduremodel} 
\end{table}

\paragraph*{\textbf{Platform}}
Platform is the property that describes where the implemented software is deployed. The difference between platforms is calculated with the porting costs from one platform to another. This costs are calculated with the main programming language of the platform, quality assurance, system type and the deployment difficulty.\\
VERGLEICH BESCHREIBEN
\begin{table}[h]
	\centering 
	\setlength{\tabcolsep}{4pt}
	\begin{tabular}{|l|l|c|}\hline
		Platform			& Porting to 	&  Costs 	\\ \hline
		Android   			& IOS					& 3      		\\ \hline
		Android   			& Windows Phone 		& 3      		\\ \hline
		Android   			& Mac OS 				& 5     		\\ \hline
		Android   			& Linux 				& 4     		\\ \hline
		Android  			& Windows 7 			& 5     		\\ \hline
		Android  			& Windows 8				& 5     		\\ \hline
		Android  			& Windows 10 			& 5     		\\ \hline
		Android  			& Windows Universal App	& 6     		\\ \hline
		Android  			& Web Development 		& 5     		\\ \hline
		Android  			& Other 				& 7     		\\ \hline
	\end{tabular} 
	\caption{Platform - Porting cost} 
	\label{property:platform} 
\end{table}\newpage

\paragraph*{\textbf{Industry Sector}}
For the industry sector there is no calculated distance as it is mostly an empiric property. It simply compared if the selected sectors are equal or not. If the industry sector does not apply to one of the available sectors there is the option to select \textit{Other} as sector. For the calculation the distance between industry sectors is set to \textit{zero} if they are equal and  \textit{one} otherwise. The available options for this property are:
\begin{itemize}
	\item \textit{Agriculture}
	\item \textit{Automotive}
	\item \textit{Banking}
	\item \textit{Bars and Restaurants}
	\item \textit{Business Service}
	\item \textit{Construction}
	\item \textit{Education}
	\item \textit{Electronics}
	\item \textit{Entertainment}
	\item \textit{Finance}
	\item \textit{Health}
	\item \textit{Internet}
	\item \textit{Music Production}
\end{itemize}

\paragraph*{\textbf{Programming Language}}
The Programming Language describes the main language for the project. As an example for the platform Android the main programming language would be Java. This Property has the most values for calculating the distance between two options. It is divided in two parts. \textbf{Part one} is calculating distance on the basis of programming language properties as described by Ruknet \cite{ruknet}. He categorized the programming languages with 12 different properties:
\begin{enumerate}
	\item \textbf{Imperative}\\ This value focuses in describing how a program operates. It simply exists on a sequence of instruction.
	\item \textbf{Object Oriented}\\ This Property describes if the language supports the concept of objects.
	\item \textbf{Functional}\\ These property is a programming paradigm that treats computation as the evaluation of mathematical functions. 
	\item \textbf{Procedural}\\ This programming paradigm allows routines and subroutines and contains a series of computational steps.
	\item \textbf{Generic}\\ Generic programming is a style which allows algorithms to be written in terms of types \textit{to-be-specified-later} that are then \textit{instantiated} when they are needed.
	\item \textbf{Reflective}\\ This is the ability of a programming language to examine and modify its own structure and behavior.
	\item \textbf{Event-Driven}\\ An event-driven programming language is determined by events such as user actions or messages from other programs.
	\item \textbf{Failsafe}\\ The ability to throw exceptions if an operation or other system calls fails is known as fail safety.
	\item \textbf{Type Safety}\\States if a programming language discourages or prevents type errors which are stated in the values \textit{safe} or \textit{unsafe}.
	\item \textbf{Type Expression}\\ This property describes if the programmer must explicitly associate each variable with a particular type.
	\item \textbf{Type Compatibility}\\ This implies the use of a type checker in the programming language which verifies if an expression is consistent with the expected type by the context in which that expression appears.
	\item \textbf{Type Checking}\\ A process of verifying and enforcing the constraints of types at run-time or compile time.\\
\end{enumerate}
Each property is converted to a numerical representation form which represents each of the possible values. For most of the properties this is simple as the possible values are \textit{true} and \textit{false} which are representet as \textit{1} and \textit{0} in table \ref{property:proglang}. Four values can not be distinguished in true or false. For failsafe exist, beside safe and unsafe, the value \textit{unkown}. In this case the value 0 means unknown, 1 is unsafe and 2 means safe. Type expression has also three values which are implicit, explicit an unknown. Implicit is represented as 1, explicit as 2 and unknow as 0. The three values for type compatibility are nominal, structual and not stated. These values are also represented as 1 for nominal, 2 for structual and 0 for not stated. The last property with more options is type checking. It can seperated in static, danymic and unknown. These are represented as 1 for static and 2 for dynamic. Unkown is as in the properties before represented as 0.\\
This allows a calculation of the \textit{Distance} of two programming languages. As described in equation \ref{pl:distanceequation} this calculated with the absolute value of each category. The constant \textit{c} is the amount of all categories, which is twelve. For each category \textit{$K_i$} of the compared programming language the value of the other language is subtracted. This summed up is the distance of these two languages.
\begin{equation}
\textit{Distance} = \sum \limits_{i=1}^c \lvert K_i - K'_i\rvert \label{pl:distanceequation}
\end{equation}
Table \ref{property:proglang} describes the comparison between C++ and Java as an example. Those two programming languages only differ in two categories, namely reflective and failsafe. To calculate the distance for those two languages the differnce between these categories is calculated with the equation from \ref{pl:distanceequation}. The result is a distance of 3.\\
\begin{table}[h]
	\centering 
	\setlength{\tabcolsep}{4pt}
	\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|c|}
		\multicolumn{1}{c}{\textbf{Programming Language}}& \multicolumn{1}{c}{\rotatebox{90}{imperative} }&  \multicolumn{1}{c}{\rotatebox{90}{object oriented}} &  \multicolumn{1}{c}{\rotatebox{90}{functional}}&  \multicolumn{1}{c}{\rotatebox{90}{procedural}}& \multicolumn{1}{c}{\rotatebox{90}{generic}}&  \multicolumn{1}{c}{\rotatebox{90}{reflective}}& \multicolumn{1}{c}{\rotatebox{90}{event driven}}&  \multicolumn{1}{c}{\rotatebox{90}{failsafe}}&  \multicolumn{1}{c}{\rotatebox{90}{type safety}}&  \multicolumn{1}{c}{\rotatebox{90}{type expression}}&  \multicolumn{1}{c}{\rotatebox{90}{type compatability}}&  \multicolumn{1}{c}{\rotatebox{90}{type checking}}\\ \hline
		C++   				& 1& 1 & 1 & 1& 1& 0& 0& 0& 1& 2& 1& 1    		\\ \hline
		Java   				& 1& 1 & 1 & 1& 1& 1& 0& 2& 1& 2& 1& 1    		\\ \hline
	\end{tabular} 
	\caption{Programming Language - Distance} 
	\label{property:proglang} 
\end{table}\\
The \textbf{second part} is calculating conversion cost in another language which is the estimated effort for converting the source code. These are calculated with the equation \ref{pl:conversioncosts} delivers, which estimates the cost factor for a conversion. These costs are simplfyfied as the \textit{Amount} of different categories plus an constant effort factor of one. This equation shoul illustrate that each different category generates effort for transforming the source code. It has to be adapted for different code paradigms and functionalities. \\
\begin{equation}
\textit{Conversion Costs} = \textit{Amount} + 1\label{pl:conversioncosts}
\end{equation}\\
In the case of a conversion between C++ an Java we have an amount of different columns of 2. Summate with the constant cost factor from the equation the conversion costs, as described in table \ref{property:proglangconversion}, are 3.\\
\begin{table}[h]
	\centering 
	\setlength{\tabcolsep}{4pt}
	\begin{tabular}{|l|l|c|}\hline
		Programming Language	& Converting to &  Distance 	\\ \hline
		Java   				& Cpp		& 3      		\\ \hline
	\end{tabular} 
	\caption{Programming Language - Conversion Cost} 
	\label{property:proglangconversion} 
\end{table}\\
To get a total distance between two programming languages, the distance and conversion costs are summarized, as described in equation \ref{pl:totaldistance}. In the example of C++ and Java we have a distance of 3 and conversion costs of 3 which results in a total distance of 6.
\begin{equation}
\textit{Total Distance} = \textit{Distance} + \textit{Conversion Costs}\label{pl:totaldistance}
\end{equation}\\
The available languages for this property are C, C\#, C++, COBOL, Clojure, Java, Javascript, Matlab, Objective-C, PHP, Prolog, Python and Scala. The complete categorization and converting costs of all programming languages can be found in the appendix XXX.

\paragraph*{\textbf{Software Architecture}}
Software Architecture describes the high level structure of a software system and comprises software elements, relations among them, and properties of both elements and relations. This property set the architecture of the project. It allows a differentiation on the fundamental structural choices which is important as it is costly to change a once implemented architecture.\\
The available options are client-server, eventdriven architecture, layered architecture, microkernel, microservices, model view controller, serviceoriented architecture and space based architecture. These architectures are categorized with the help of architecture patterns as described by Richards \cite{archpatterns}. He analyzed software architectures by classifying them into overall agility, ease of deployment, testability, performance, scalability and ease of development. These are the categories in which a software achitecture can be divided into. Each of the values is stated with low, medium or high.\\
\begin{itemize}
	\item \textbf{Overall Agility}\\Describes the ability to respond to a constantly changing environment.
	\item \textbf{Ease of Deployment}\\This category describes the deoployment process and how changes affect deployment.
	\item \textbf{Testability}\\The way of how the architecture can be tested is decribed with this category.
	\item \textbf{Performance}\\The ability a pattern can be lend to high-performance applications is described by Performance.
	\item \textbf{Scalability}\\Scalability describes how good the application with this pattern can be scaled.
	\item \textbf{Ease of Development}\\This describes the complexity for implementing the architecture.\\
\end{itemize}
Each software architecture can be subdivided with these properties and also different categories which are distributed, interactive, adaptive and mud-to-structure. Table \ref{property:architecture} describes the categorization of layered and eventdriven pattern as an example. The categorization of all available patterns can be found in the appendix XXX.\\
The layered architecture is the de facto standard for most Java EE applications and therefore is widely known by most architects, designers, and developers. It is time-consuming to make changes in this architecture pattern because of the monolithic nature of most implementations and one small change to a component can require a redeployment of the entire application. The pattern can be easily tested by mocking or stubbing layers. As some layer applications may run well, the pattern itselt is not a high-performance architecture, also scaling applications with this pattern is hard due to different layers. Because this pattern is well known and not overly complex to implement the ease of development is considered as high.\\
The Eventdriven architecture is a distributed asynchronous architecture pattern used to produce higy scalable applications.Changes are generally isolated to one or a few event processors and can be made quickly without impacting other components. It tends to be easier to this architecture deploy than the mediator topology, primarily because the event mediator component is tightly coupled to the event processors. Testing is complicated by the asynchronous nature of this pattern. The pattern achieves high performance through its asynchronous capabilities. Scalability is naturally achieved in this pattern through highly independent and decoupled event processors. Development can be complicated due to the asynchronous nature of the pattern as well as contract creation and the need for more advanced error handling conditions. The properties of the described patterns are visualized in table \ref{property:architecture}.\\
To calculate the distance between these to architectures each property of the architecure will be substracted with the property from the other architecture as described in equation \ref{archdistance}. These calculation is the same as the distance for the programming languages. For the different categories the value 1 is added if they are not equal and 0 if they are. 
\begin{equation}
\textit{Architecture Distance} = \sum \limits_{i=1}^c \lvert P_i - P'_i\rvert\label{archdistance}
\end{equation}\\
In the case of the comparison of Layered Architecture and Eventdriven Architecture, as described in \ref{property:architecture}, the result of the distance calculation is 12. As the categories are not equal the value 1 is added to the distance which results in a total distance of 13 for these two patterns.
\begin{table}[h]
	\centering 
	\setlength{\tabcolsep}{4pt}
	\begin{tabular}{|l|c|c|c|c|c|c|c|}
		\multicolumn{1}{c}{\textbf{Software Architecture}}& \multicolumn{1}{c}{Category }&  \multicolumn{1}{c}{\rotatebox{90}{overall agility}} &  \multicolumn{1}{c}{\rotatebox{90}{ease of deployment}}&  \multicolumn{1}{c}{\rotatebox{90}{testability}}& \multicolumn{1}{c}{\rotatebox{90}{performance}}&  \multicolumn{1}{c}{\rotatebox{90}{scalability}}& \multicolumn{1}{c}{\rotatebox{90}{ease of development}}\\ \hline
		Layered Architecture   		& distributed& 1& 1 & 3& 1& 1& 3   		\\ \hline
		Eventdriven Architecture	& interactive& 3& 3 & 1& 3& 3& 1    		\\ \hline
	\end{tabular} 
	\caption{Software Architecture - Distance} 
	\label{property:architecture} 
\end{table}

\paragraph*{\textbf{2. Determination of the Total Distance}}
Calculating the total distance of two projects is done with the equation \ref{totaldistance}. 
\begin{equation}
\textit{Total Distance} = \sum \limits_{i=1}^n ( D_i \cdot Weight_i )\label{totaldistance}
\end{equation}

\begin{table}[h]
	\centering 
	\setlength{\tabcolsep}{4pt}
	\begin{tabular}{|l|c|}\hline
		Property	& Weight 	\\ \hline
		Estimation Method   	& 1      	\\ \hline
		Development Market   	& 2      	\\ \hline
		Development Type   		& 3      	\\ \hline
		Procedure Model   		& 2      	\\ \hline
		Platform   				& 1.5      	\\ \hline
		Industry Sector   		& 1      	\\ \hline
		Programming Language   	& 1      	\\ \hline
		Software Architecture   & 1      	\\ \hline
	\end{tabular} 
	\caption{Property Weights} 
	\label{propertyweights} 
\end{table}
\paragraph*{\textbf{3. Calculation of the Relation}}
asdasdasd\\
\begin{equation}
\textit{Percentage Difference} =  (\frac{\textit{Total Distance}}{\textit{Max}})\cdot 100\label{difference}
\end{equation}

\begin{equation}
\textit{Relation} =  100 - \textit{Percentage Difference} \label{relation}
\end{equation}
\paragraph*{\textbf{Example Calculation}}
asdasd

\subsection{Project Analyzer}

Aufbau der Analyze der Projekte, Wie die Graphen vorgestellt. Sinn davon

\subsection{Minor Components}

Export, statistic, Help DB, Feedback, Project Filter, accessing resources


\section{Database design}

Vorheriges Design der zentralen Datenbank. Wichtig um die Klassen anzupassen und vorher schon mit wichtigen Daten zu füllen

\subsection{Project Database}

Datenbank für alle Projekte, Eigenschaften, Einflussfaktoren

\subsubsection{Project Properties}

Welche Tabellen gibt es. Wichtige Tabellen, Aufbau der Tabellen und Grund

\subsubsection{Influence Factors}

Wie die Einflussfaktoren Aufgebaut, was ist der Gedanke dazu?

\subsubsection{Projects}

Wie sind Projekte gespeichert, Aufteilung in Projekt, Projektdetails und zugehörige Tabellen, wie die Schätzung Organisiert und wie der Zugriff auf die Elemente

\subsection{Userinformation Database}

Datenbank für Spätere Synchronisation und Userinformationen vom Server, Konzept dazu

\section{User Interface}

\subsection{Projects Overview}

Anordnung der Projekte, Wichtige Informationen zum sehen, Filtern und Suchen nach Projekten

\subsection{Project Creation}

Komponente zur korrekten Erstellung von Projekten, Geführte Eingabe, Korrekte Erstellung von Projekten in der DB, Swipe Funktion

\subsection{Estimate Function Point Project}

Aufbau der Schätzung, Umwandlung von Tabelle in App

\subsection{Influence Factors}

Aufbau der EInflussfaktoren, Neue anlengen

\subsection{Analysis}

Wie die Analyse aufgebau und was soll diese bringen?

\section{Adjusted Estimation Process}\label{adjustedEstimationProcess}


\subsection{Continuous Improvement of the Estimation}

